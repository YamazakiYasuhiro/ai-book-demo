# CI/CD 実装計画書

## 1. 概要

### 1.1 目的

`01-003-CICD.md` に記載された要件に基づき、以下のCI/CDプロセスを自動化するスクリプトと、それを支える結合テスト基盤を構築する。

1. コンテナ群の停止
2. 単体テストの実行
3. コンテナ群のビルド
4. コンテナ群の起動
5. 結合テストの実行

### 1.2 現状の課題

| 課題 | 現在の実装 | 目標 |
|------|-----------|------|
| CI/CDプロセスの手動化 | 各ステップを手動で実行 | 単一スクリプトで全自動化 |
| 結合テストの不在 | 単体テストのみ存在 | Web API/UIの結合テスト追加 |
| コード完了基準の曖昧さ | 明確な基準なし | CI/CD全パスを完了基準に |
| テストファイル規約の不在 | 規約が明文化されていない | 1ソース:1テストの規約化 |

### 1.3 スコープ

**実装する機能:**
- `build.sh` スクリプト（スキップオプション付き）
- 結合テストフレームワーク（`tests/integration/`）
- テストユーティリティ（`tests/utils/`）
- 基本ルールの更新（CI/CD完了基準、テスト規約）

**対象外（将来検討）:**
- GitHub Actions/GitLab CI との連携
- 自動デプロイ機能
- テストレポート生成

---

## 2. 技術設計

### 2.1 CI/CDプロセスフロー

```
┌─────────────────────────────────────────────────────────────┐
│                      build.sh                               │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. Stop Containers                                         │
│     └─> docker compose down                                 │
│                                                             │
│  2. Unit Tests (--skip-tests でスキップ可能)                │
│     └─> cd backend && go test ./...                         │
│     └─> cd frontend && yarn test                            │
│                                                             │
│  3. Build Containers (--skip-build でスキップ可能)          │
│     └─> docker compose build                                │
│                                                             │
│  4. Start Containers (--skip-start でスキップ可能)          │
│     └─> docker compose up -d                                │
│     └─> Wait for health check                               │
│                                                             │
│  5. Integration Tests (--skip-test でスキップ可能)          │
│     └─> cd tests && go test ./integration/...               │
│                                                             │
│  6. Report Results                                          │
│     └─> Success / Failure summary                           │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 build.sh スクリプト設計

```bash
#!/bin/bash
#
# CI/CD Build Script
# Executes the complete build and test pipeline
#
# Options:
#   --skip-tests  : Skip unit tests
#   --skip-build  : Skip container build
#   --skip-start  : Skip container startup
#   --skip-test   : Skip integration tests
#   --help        : Show help message
#

set -e  # Exit on error

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Default flags
SKIP_TESTS=false
SKIP_BUILD=false
SKIP_START=false
SKIP_TEST=false

# Parse arguments
for arg in "$@"; do
    case $arg in
        --skip-tests) SKIP_TESTS=true ;;
        --skip-build) SKIP_BUILD=true ;;
        --skip-start) SKIP_START=true ;;
        --skip-test)  SKIP_TEST=true ;;
        --help)       show_help; exit 0 ;;
    esac
done

# Pipeline steps...
```

### 2.3 結合テストディレクトリ構造

```
tests/
├── go.mod                    # tests module definition
├── go.sum
├── integration/
│   ├── api_test.go          # Web API tests
│   ├── avatar_test.go       # Avatar management API tests
│   ├── conversation_test.go # Conversation API tests
│   ├── health_test.go       # Health check API tests
│   └── message_test.go      # Message sending API tests
└── utils/
    ├── client.go            # HTTP client utilities
    ├── setup.go             # Test setup/teardown helpers
    └── assertions.go        # Custom test assertions
```

### 2.4 結合テスト設計

#### 2.4.1 テスト対象API

| エンドポイント | メソッド | テスト内容 |
|---------------|---------|-----------|
| `/health` | GET | サーバー稼働確認 |
| `/api/avatars` | GET | アバター一覧取得 |
| `/api/avatars` | POST | アバター作成 |
| `/api/avatars/{id}` | GET | アバター詳細取得 |
| `/api/conversations` | GET | 会話一覧取得 |
| `/api/conversations` | POST | 会話作成 |
| `/api/conversations/{id}` | GET | 会話詳細取得 |
| `/api/conversations/{id}/messages` | GET | メッセージ一覧取得 |
| `/api/conversations/{id}/messages` | POST | メッセージ送信 |
| `/api/conversations/{id}/avatars` | POST | アバター参加 |
| `/api/conversations/{id}/avatars/{avatarId}` | DELETE | アバター退室 |

#### 2.4.2 テストユーティリティ設計

```go
// tests/utils/client.go
package utils

import (
    "net/http"
    "time"
)

// TestClient wraps HTTP client for integration tests
type TestClient struct {
    BaseURL    string
    HTTPClient *http.Client
}

// NewTestClient creates a new test client
func NewTestClient(baseURL string) *TestClient {
    return &TestClient{
        BaseURL: baseURL,
        HTTPClient: &http.Client{
            Timeout: 30 * time.Second,
        },
    }
}

// GET performs a GET request
func (c *TestClient) GET(path string) (*http.Response, error)

// POST performs a POST request with JSON body
func (c *TestClient) POST(path string, body any) (*http.Response, error)

// DELETE performs a DELETE request
func (c *TestClient) DELETE(path string) (*http.Response, error)
```

```go
// tests/utils/setup.go
package utils

// TestSuite provides setup/teardown for integration tests
type TestSuite struct {
    Client *TestClient
}

// NewTestSuite creates a new test suite
func NewTestSuite() *TestSuite

// WaitForServer waits until the server is healthy
func (s *TestSuite) WaitForServer(timeout time.Duration) error

// CleanupTestData removes test data created during tests
func (s *TestSuite) CleanupTestData() error
```

---

## 3. 基本ルール更新計画

### 3.1 追加するルール

以下の内容を `prompts/00_rules/00-000-FundamentalRules.md` に追記する。

#### 3.1.1 CI/CDプロセス

```markdown
## CI/CDプロセス

### コード完了の定義
- すべてのコード変更は、CI/CDプロセスの結合テストまでクリアすることで完了とする
- CI/CDプロセスが失敗した場合、原因を特定し、コードを改善することを繰り返す
- 最終的なコード完了確認は、`./build.sh` をオプションなしで実行して成功すること

### build.sh スクリプト
- `./build.sh` は以下の順序でCI/CDプロセスを実行する：
  1. コンテナ群の停止
  2. 単体テストの実行
  3. コンテナ群のビルド
  4. コンテナ群の起動
  5. 結合テストの実行

### スキップオプション
- `--skip-tests`: 単体テストをスキップ
- `--skip-build`: コンテナビルドをスキップ
- `--skip-start`: コンテナ起動をスキップ
- `--skip-test`: 結合テストをスキップ

**注意**: スキップオプションは開発中の時間短縮のためのみ使用すること。
改善されないプロセスを無視するために使用してはならない。
```

#### 3.1.2 テスト規約

```markdown
## テスト規約

### 単体テスト
- 原則として、すべてのGoソースファイルに対応する単体テストファイルを作成する
- 命名規則: `<filename>.go` → `<filename>_test.go`
- 例: `backend/internal/api/conversation.go` → `backend/internal/api/conversation_test.go`
- テストはTDD（テスト駆動開発）のアプローチで開発する

### 結合テスト
- 結合テストは `tests/integration/` に配置する
- テストユーティリティは `tests/utils/` に配置する
- 結合テストはコンテナが起動した状態で実行する
- Web APIの全エンドポイントをテストする
```

---

## 4. 実装フェーズ

### Phase 1: 基盤構築（優先度: 高）

**目標**: build.sh スクリプトの基本実装

**タスク**:
1. `build.sh` スクリプトの作成
2. オプション解析の実装
3. 各ステップの基本処理実装
4. エラーハンドリングの実装
5. カラー出力とログメッセージの実装

**成果物**:
- `build.sh`

### Phase 2: 結合テスト基盤（優先度: 高）

**目標**: 結合テストフレームワークの構築

**タスク**:
1. `tests/go.mod` の作成
2. `tests/utils/client.go` の実装
3. `tests/utils/setup.go` の実装
4. `tests/utils/assertions.go` の実装

**成果物**:
- `tests/go.mod`
- `tests/utils/client.go`
- `tests/utils/setup.go`
- `tests/utils/assertions.go`

### Phase 3: 結合テスト実装（優先度: 高）

**目標**: 主要APIの結合テスト実装

**タスク**:
1. `tests/integration/health_test.go` の実装
2. `tests/integration/avatar_test.go` の実装
3. `tests/integration/conversation_test.go` の実装
4. `tests/integration/message_test.go` の実装

**成果物**:
- `tests/integration/health_test.go`
- `tests/integration/avatar_test.go`
- `tests/integration/conversation_test.go`
- `tests/integration/message_test.go`

### Phase 4: 基本ルール更新（優先度: 高）

**目標**: 基本ルールファイルの更新

**タスク**:
1. CI/CDプロセスセクションの追加
2. テスト規約セクションの追加
3. コード完了の定義の追加

**成果物**:
- `prompts/00_rules/00-000-FundamentalRules.md` の更新

### Phase 5: 検証・調整（優先度: 中）

**目標**: 全体の動作確認と調整

**タスク**:
1. `./build.sh` の全ステップ実行確認
2. 各スキップオプションの動作確認
3. エラー発生時の動作確認
4. 結合テストの全パス確認

**成果物**:
- 動作確認完了

---

## 5. タスク一覧

| ID | タスク | フェーズ | 依存 | 優先度 | 見積もり |
|----|-------|---------|------|--------|---------|
| T1 | build.sh 基本構造作成 | P1 | - | 高 | 30分 |
| T2 | オプション解析実装 | P1 | T1 | 高 | 15分 |
| T3 | コンテナ停止処理実装 | P1 | T1 | 高 | 10分 |
| T4 | 単体テスト実行処理実装 | P1 | T1 | 高 | 15分 |
| T5 | コンテナビルド処理実装 | P1 | T1 | 高 | 10分 |
| T6 | コンテナ起動処理実装 | P1 | T1 | 高 | 15分 |
| T7 | 結合テスト実行処理実装 | P1 | T1 | 高 | 10分 |
| T8 | tests/go.mod 作成 | P2 | - | 高 | 5分 |
| T9 | tests/utils/client.go 実装 | P2 | T8 | 高 | 30分 |
| T10 | tests/utils/setup.go 実装 | P2 | T8 | 高 | 20分 |
| T11 | tests/utils/assertions.go 実装 | P2 | T8 | 中 | 15分 |
| T12 | health_test.go 実装 | P3 | T9,T10 | 高 | 15分 |
| T13 | avatar_test.go 実装 | P3 | T9,T10 | 高 | 30分 |
| T14 | conversation_test.go 実装 | P3 | T9,T10 | 高 | 30分 |
| T15 | message_test.go 実装 | P3 | T9,T10 | 高 | 30分 |
| T16 | 基本ルール CI/CD セクション追加 | P4 | - | 高 | 15分 |
| T17 | 基本ルール テスト規約追加 | P4 | - | 高 | 10分 |
| T18 | 全体動作確認 | P5 | T1-T17 | 高 | 30分 |

**合計見積もり時間**: 約5時間

---

## 6. 実装詳細

### 6.1 build.sh 完全実装

```bash
#!/bin/bash
#
# CI/CD Build Script
# Executes the complete build and test pipeline
#

set -e

# ============================================================
# Configuration
# ============================================================

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$SCRIPT_DIR"

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Default flags
SKIP_TESTS=false
SKIP_BUILD=false
SKIP_START=false
SKIP_TEST=false

# ============================================================
# Functions
# ============================================================

log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

show_help() {
    cat << EOF
Usage: ./build.sh [OPTIONS]

CI/CD Build Script - Executes the complete build and test pipeline

Options:
    --skip-tests    Skip unit tests
    --skip-build    Skip container build
    --skip-start    Skip container startup
    --skip-test     Skip integration tests
    --help          Show this help message

Process:
    1. Stop running containers
    2. Run unit tests (backend and frontend)
    3. Build containers
    4. Start containers
    5. Run integration tests

Examples:
    ./build.sh                      # Run full pipeline
    ./build.sh --skip-tests         # Skip unit tests
    ./build.sh --skip-build         # Skip container build
    ./build.sh --skip-tests --skip-build  # Skip both
EOF
}

step_stop_containers() {
    log_info "Step 1: Stopping containers..."
    cd "$PROJECT_ROOT"
    docker compose down --remove-orphans 2>/dev/null || true
    log_success "Containers stopped"
}

step_unit_tests() {
    if [ "$SKIP_TESTS" = true ]; then
        log_warning "Skipping unit tests (--skip-tests)"
        return 0
    fi

    log_info "Step 2: Running unit tests..."

    # Backend tests
    log_info "Running backend tests..."
    cd "$PROJECT_ROOT/backend"
    go test ./... -v

    # Frontend tests
    log_info "Running frontend tests..."
    cd "$PROJECT_ROOT/frontend"
    yarn test --watchAll=false

    log_success "Unit tests passed"
}

step_build_containers() {
    if [ "$SKIP_BUILD" = true ]; then
        log_warning "Skipping container build (--skip-build)"
        return 0
    fi

    log_info "Step 3: Building containers..."
    cd "$PROJECT_ROOT"
    docker compose build
    log_success "Containers built"
}

step_start_containers() {
    if [ "$SKIP_START" = true ]; then
        log_warning "Skipping container startup (--skip-start)"
        return 0
    fi

    log_info "Step 4: Starting containers..."
    cd "$PROJECT_ROOT"
    docker compose up -d

    # Wait for health check
    log_info "Waiting for server to be healthy..."
    local max_attempts=30
    local attempt=0
    while [ $attempt -lt $max_attempts ]; do
        if curl -s http://localhost:8080/health > /dev/null 2>&1; then
            log_success "Server is healthy"
            return 0
        fi
        attempt=$((attempt + 1))
        sleep 1
    done

    log_error "Server failed to become healthy within ${max_attempts} seconds"
    exit 1
}

step_integration_tests() {
    if [ "$SKIP_TEST" = true ]; then
        log_warning "Skipping integration tests (--skip-test)"
        return 0
    fi

    log_info "Step 5: Running integration tests..."
    cd "$PROJECT_ROOT/tests"
    go test ./integration/... -v
    log_success "Integration tests passed"
}

# ============================================================
# Main
# ============================================================

main() {
    # Parse arguments
    for arg in "$@"; do
        case $arg in
            --skip-tests) SKIP_TESTS=true ;;
            --skip-build) SKIP_BUILD=true ;;
            --skip-start) SKIP_START=true ;;
            --skip-test)  SKIP_TEST=true ;;
            --help)       show_help; exit 0 ;;
            *)
                log_error "Unknown option: $arg"
                show_help
                exit 1
                ;;
        esac
    done

    echo ""
    echo "========================================"
    echo "       CI/CD Pipeline Starting"
    echo "========================================"
    echo ""

    local start_time=$(date +%s)

    # Execute pipeline steps
    step_stop_containers
    step_unit_tests
    step_build_containers
    step_start_containers
    step_integration_tests

    local end_time=$(date +%s)
    local duration=$((end_time - start_time))

    echo ""
    echo "========================================"
    log_success "CI/CD Pipeline Completed Successfully!"
    echo "        Duration: ${duration} seconds"
    echo "========================================"
    echo ""
}

main "$@"
```

### 6.2 tests/go.mod

```go
module github.com/your-org/ai-book-demo/tests

go 1.23

require (
    github.com/stretchr/testify v1.9.0
)
```

### 6.3 tests/utils/client.go

```go
package utils

import (
    "bytes"
    "encoding/json"
    "fmt"
    "io"
    "net/http"
    "time"
)

// TestClient wraps HTTP client for integration tests
type TestClient struct {
    BaseURL    string
    HTTPClient *http.Client
}

// NewTestClient creates a new test client
func NewTestClient(baseURL string) *TestClient {
    return &TestClient{
        BaseURL: baseURL,
        HTTPClient: &http.Client{
            Timeout: 30 * time.Second,
        },
    }
}

// GET performs a GET request
func (c *TestClient) GET(path string) (*http.Response, error) {
    return c.HTTPClient.Get(c.BaseURL + path)
}

// POST performs a POST request with JSON body
func (c *TestClient) POST(path string, body any) (*http.Response, error) {
    jsonBody, err := json.Marshal(body)
    if err != nil {
        return nil, fmt.Errorf("failed to marshal body: %w", err)
    }

    return c.HTTPClient.Post(
        c.BaseURL+path,
        "application/json",
        bytes.NewReader(jsonBody),
    )
}

// DELETE performs a DELETE request
func (c *TestClient) DELETE(path string) (*http.Response, error) {
    req, err := http.NewRequest(http.MethodDelete, c.BaseURL+path, nil)
    if err != nil {
        return nil, fmt.Errorf("failed to create request: %w", err)
    }
    return c.HTTPClient.Do(req)
}

// ReadJSON reads response body as JSON into target
func ReadJSON(resp *http.Response, target any) error {
    defer resp.Body.Close()
    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return fmt.Errorf("failed to read body: %w", err)
    }
    return json.Unmarshal(body, target)
}
```

### 6.4 tests/utils/setup.go

```go
package utils

import (
    "fmt"
    "net/http"
    "os"
    "time"
)

const (
    DefaultBaseURL = "http://localhost:8080"
    DefaultTimeout = 30 * time.Second
)

// TestSuite provides setup/teardown for integration tests
type TestSuite struct {
    Client *TestClient
}

// NewTestSuite creates a new test suite
func NewTestSuite() *TestSuite {
    baseURL := os.Getenv("TEST_BASE_URL")
    if baseURL == "" {
        baseURL = DefaultBaseURL
    }

    return &TestSuite{
        Client: NewTestClient(baseURL),
    }
}

// WaitForServer waits until the server is healthy
func (s *TestSuite) WaitForServer(timeout time.Duration) error {
    deadline := time.Now().Add(timeout)
    for time.Now().Before(deadline) {
        resp, err := http.Get(s.Client.BaseURL + "/health")
        if err == nil && resp.StatusCode == http.StatusOK {
            resp.Body.Close()
            return nil
        }
        if resp != nil {
            resp.Body.Close()
        }
        time.Sleep(500 * time.Millisecond)
    }
    return fmt.Errorf("server did not become healthy within %v", timeout)
}
```

### 6.5 tests/integration/health_test.go

```go
package integration

import (
    "net/http"
    "testing"
    "time"

    "github.com/your-org/ai-book-demo/tests/utils"
)

func TestHealthEndpoint(t *testing.T) {
    suite := utils.NewTestSuite()

    // Wait for server
    if err := suite.WaitForServer(10 * time.Second); err != nil {
        t.Fatalf("Server not ready: %v", err)
    }

    // Test health endpoint
    resp, err := suite.Client.GET("/health")
    if err != nil {
        t.Fatalf("Failed to call health endpoint: %v", err)
    }
    defer resp.Body.Close()

    if resp.StatusCode != http.StatusOK {
        t.Errorf("Expected status 200, got %d", resp.StatusCode)
    }
}
```

---

## 7. 注意事項

### 7.1 スキップオプションの適切な使用

- スキップオプションは**開発中の時間短縮目的**でのみ使用する
- コード変更の最終確認時は、必ず**オプションなし**で実行する
- 失敗するテストを無視するためにスキップオプションを使用してはならない

### 7.2 結合テストの前提条件

- 結合テストは**コンテナが起動した状態**で実行する
- `--skip-start` と `--skip-test` を同時に使用しない場合、コンテナが起動していることを確認する
- テスト用のデータは各テストケースで作成・クリーンアップする

### 7.3 既存の単体テストとの整合性

- 既存の単体テストファイル構成は維持する
- 新しいソースファイルを追加した場合は、対応するテストファイルも必ず作成する
- `models/models.go` のようなデータ構造のみのファイルはテスト不要

---

## 8. 今後の拡張案

### 8.1 短期的な拡張

- テストカバレッジレポートの生成
- テスト結果のサマリー出力改善
- 並列テスト実行の最適化

### 8.2 長期的な拡張

- GitHub Actions との連携
- 自動デプロイパイプライン
- E2Eテスト（Playwright/Cypress）の追加
- パフォーマンステストの追加

